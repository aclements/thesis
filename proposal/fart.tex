OVERSTATED SIX WAYS TO SUNDAY

What is hard about parallel programming?
%
It's not necessarily \emph{correctness}: it is simple to write a program that uses parallel resources correctly---simply surround the program with a coarse-grained lock, sacrificing performance.
%
And a relatively simple methodology, common to all scalable software practitioners for many years, can move from a correct program to a correct, scalable program:

\begin{enumerate}
\item Measure the performance of the program on the target machine.
\item Find the contended locks.
\item Make those locks more scalable by dividing them into finer-grained locks while preserving correctness.
\end{enumerate}

[[CITE DOC BY SUN/SGI ENGINEERS?? CAN'T FIND IT NOW]]~\cite{cacm-real-world}

This methodology is simple, obvious, and inescapable. It's also the biggest problem with designing truly scalable software. The reason: \emph{the first step is unpredictable}.

\XXX[nz][merge into intro starting from here]

In no other area of computer systems design can short-term hardware changes so dramatically shift bottlenecks. A lock that's totally uncontended in one hardware generation---for instance, because underlying hardware is slow---can become a dominant factor in the next. And, unusually, scaling problems can make software \emph{slower} on more powerful hardware than it was on a previous generation!

This leaves systems designers on unstable ground. In other areas of systems design, optimizations for one generation of hardware don't work against performance on a later generation. But in multicore programming, this is common. For one small example, the extra work required to maintain a scalable lock can significantly slow down a system with relatively few cores; but a non-scalable lock will crash performance hard on a larger number of cores.

Thus, systems can't really be made scalable without measurements, and measurements produce surprising results on each hardware generation. Systems designers are left without firm principles that can produce software that scales over \emph{multiple} hardware generations. Only many years after an interface is introduced can users discover that interface cannot be implemented truly scalably.

We propose a basic change to the construction of scalable software: software that is scalable by design.
