What fundamental opportunities for multicore scalability are latent in
software interfaces, such as system call APIs? Can scalability
opportunities be identified even before any implementation exists,
simply by considering interface specifications?
To answer these
questions this dissertation introduces the scalable commutativity rule:
\emph{Whenever interface operations commute,
they can be implemented in a way that scales.}
This rule aids developers in building scalable multicore software
starting with interface design and
carrying on through implementation, testing, and evaluation.

This dissertation formalizes the scalable commutativity rule and
defines a novel form of commutativity named \emph{\SIM commutativity}
that makes it possible to fruitfully apply the rule to complex and
highly stateful software interfaces.

To help developers apply the rule, this dissertation introduces an
automated method embodied in a new tool named \tool, which accepts
high-level interface models, generates tests of operations that
commute and hence could scale, and uses these tests to systematically
evaluate the scalability of implementations.
%
We apply \tool to a model of \pyexpr{len(mscan.calls)} POSIX file and
virtual memory system operations.
%
Using the resulting \pyexpr{mscan.ntestcases} scalability tests, \tool
systematically pinpoints many problems in the Linux kernel that past
work has observed to limit application scalability and identifies
previously unknown bottlenecks that may be triggered by future
hardware or workloads.

Finally, this dissertation applies the scalable commutativity rule and
\tool to the design and implementation of a new POSIX-like operating
system named \sys.
%
\sys's novel file and virtual memory system designs enable it to scale
for \pyexpr{percent(1-(mscan.xv6.shared/float(mscan.ntestcases)))} of
the tests generated by \tool.
%
These results translate to linear scalability on an 80~core x86
machine for applications built on \sys's commutative operations.
