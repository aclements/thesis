What fundamental opportunities for scalability are latent in
\emph{interfaces}, such as system call APIs? Can scalability
opportunities be identified even before any implementation exists,
simply by considering interface specifications?
To answer these
questions this paper introduces the following rule:
\emph{Whenever interface operations commute,
they can be implemented in a way that scales.}
This rule aids developers in building more scalable software starting from
interface design and
carrying on through implementation, testing, and evaluation.

To help developers apply the rule,
a new tool named \tool
accepts high-level interface models and generates
tests of operations that commute and hence could scale. Using
these tests, \tool can
evaluate the scalability of an implementation.  We apply \tool to
\pyexpr{len(mscan.calls)} POSIX calls and use the results to
guide the implementation of a new research operating system kernel
called \sys.
%
Linux scales for
\pyexpr{percent(1-(mscan.linux.shared/float(mscan.ntestcases)))} of
the \pyexpr{mscan.ntestcases} tests generated by \tool for these
calls, and \tool finds many problems that have been observed to limit
application scalability.
%
\sys scales for
\pyexpr{percent(1-(mscan.xv6.shared/float(mscan.ntestcases)))} of the
tests.
