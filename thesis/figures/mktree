#!/usr/bin/env python

# PYTHONPATH=$HOME/r/commuter:$PYTHONPATH

import sys
import os

import simsym
from simsym import SchedNode
from models.rename import Rename
import graph
import collections

import tools.context as context

def struct_to_dict(struct):
    return {arg: getattr(struct, arg).copy() for arg in struct._fields}

def test(base, callA, callB):
    s0 = base.var('s0')
    argsA = callA.arg_struct_type.var('a')
    argsB = callB.arg_struct_type.var('b')

    sAB = s0.copy()
    simsym.note({'type':'begin', 'region':'opA'})
    rA = callA(sAB, **struct_to_dict(argsA))
    simsym.note({'type':'end',   'region':'opA', 'result':rA})
    simsym.note({'type':'begin', 'region':'opA,opB'})
    rAB = callB(sAB, **struct_to_dict(argsB))
    simsym.note({'type':'end',   'region':'opA,opB', 'result':rAB})

    sBA = s0.copy()
    simsym.note({'type':'begin', 'region':'opB'})
    rB = callB(sBA, **struct_to_dict(argsB))
    simsym.note({'type':'end',   'region':'opB', 'result':rB})
    simsym.note({'type':'begin', 'region':'opB,opA'})
    rBA = callA(sBA, **struct_to_dict(argsA))
    simsym.note({'type':'end',   'region':'opB,opA', 'result':rBA})

    if rB != rAB:
        return 'RB'
    if rA != rBA:
        return 'RA'
    if not sAB == sBA:          # Render commutative branch as True
        return 'S'
    return 'C'

class TreeNode(object):
    def __init__(self):
        self.typ = self.val = self.band = None
        self.x, self.y = None, None
        self.children = {}

    def set(self, typ, val, region, frames):
        if self.typ is not None:
            assert self.typ == typ
            return
        self.typ = typ
        self.val = val
        self.band = tuple(region) + tuple((f.filename, f.lineno) for f in frames)

    def dump(self, indent=0, label=''):
        if label:
            label += ':'
        print "%s%s%s (band %s)" % (" "*indent, label, self.val, self.band)
        for clabel, child in node.children.items():
            child.dump(indent + 2, clabel)

class SchedTree(object):
    def __init__(self):
        self.__root = TreeNode()

    def add_sched(self, sched, result):
        node = self.__root
        region = []
        for snode in sched:
            if snode.typ == "note":
                if snode.val['type'] == 'begin':
                    region.append(snode.val['region'])
                elif snode.val['type'] == 'end':
                    if snode.val['region'] != region[-1]:
                        raise ValueError('Unbalanced note regions')
                    node.set('end', snode, region, snode.frames)
                    node = node.children.setdefault('', TreeNode())
                    region.pop()
                continue

            if snode.typ not in ("branch_det", "branch_nondet"):
                continue
            if (snode.typ == "branch_det" and
                os.path.basename(snode.frames[0].filename) == "symtypes.py"):
                # This introduces a bunch of extra deterministic
                # branches that distract from the main code, so just
                # strip them out.
                continue

            # SchedNodes are edges, but we want to label tree nodes by
            # the metadata on their outgoing edges (which will be the
            # same for both), so here we record information based on
            # the first SchedNode going out of a tree node we find.
            node.set('branch', snode, region, snode.frames)
            clabel = str(snode.val)[0]
            node = node.children.setdefault(clabel, TreeNode())
        assert region == []
        assert node.val is None
        node.set('result', result, [], [])

    def dump(self):
        self.__root.dump()

    def __apply_rec(self, fn, node=None, *args):
        if node is None:
            node = self.__root
        fn(node, *args)
        for child in node.children.values():
            self.__apply_rec(fn, child, *args)

    def layout(self):
        apply_rec = self.__apply_rec
        # Compute band order using a topo sort over bands
        # XXX This can't handle genuine loops, since they will cause
        # the same stack to appear repeatedly.  We should handle
        # these, even though it will necessarily be ambiguous.
        band_to_nodes = collections.defaultdict(list)
        def map_band(node):
            if node.band is not None:
                band_to_nodes[node.band].append(node)
        apply_rec(map_band)

        band_marks = {}
        band_order = []
        def visit_band(band):
            if band in band_marks:
                if band_marks[band] == 'temp':
                    raise ValueError("Cyclic band %r" % (band,))
                return
            band_marks[band] = 'temp'
            for node in band_to_nodes[band]:
                for child in node.children.values():
                    visit_band(child.band)
            band_marks[band] = True
            band_order.append(band)
        visit_band(self.__root.band)
        band_order.reverse()

        # Turn bands into Y coordinates
        def assign_y(py, node):
            if not node.band:
                # This should only happen in the final result node
                y = py + 1
                assert not node.children, \
                    'Band-less interior nodes not implemented'
            else:
                y = band_order.index(node.band)
            node.y = y
            for child in node.children.values():
                assign_y(y, child)
        assign_y(-1, self.__root)

        # Compute X coordinates from the bottom up (XXX could be way
        # more efficient, perhaps using deltas instead of absolutes)
        def shift(node, by):
            # Shift node right by 'by'
            node.x += by
        def hspans(ytop, subtree):
            # Compute the horizontal span at each Y, plus a stem going
            # from subtree up to ytop.
            minx, maxx = {}, {}
            def add_xy(x, y):
                if y in minx:
                    minx[y] = min(minx[y], x)
                    maxx[y] = max(maxx[y], x)
                else:
                    minx[y] = maxx[y] = x
            def hspan1(py, node):
                for y in range(py, node.y+1):
                    add_xy(node.x, y)
                for child in node.children.values():
                    hspan1(node.y, child)
            hspan1(ytop, subtree)
            return minx, maxx
        def overlap(ytop, sub1, sub2):
            # Compute the amount to shift sub2 to eliminate overlap with sub1
            _, sub1r = hspans(ytop, sub1)
            sub2l, _ = hspans(ytop, sub2)
            return 1 + max(sub1r[y] - sub2l[y] for y in sub1r if y in sub2l)
        def assign_x(node):
            if not node.children:
                node.x = 0.0
                return
            prev_child = None
            for child in node.children.values():
                assign_x(child)
                if prev_child is not None:
                    apply_rec(shift, child, overlap(node.y, prev_child, child))
                prev_child = child
            node.x = (sum(child.x for child in node.children.values()) /
                      len(node.children))
        assign_x(self.__root)

    def to_ctx(self, ctx, S):
        """Draw self to ctx.  S is the unit size of the node grid."""
        self.layout()
        NODE_RADIUS = S * 0.1
        LABEL_PAD = S * 0.15
        STROKE_WIDTH = S * 0.04
        NODE_LABEL_SIZE = 5 * S / 13   # 5pt at S=13
        BRANCH_LABEL_SIZE = 4 * S / 13 # 4pt at S=13

        # Render bands (hard-coded for rename, meh)
        BAND_LEFT = -2
        band_ys = [S * (band * 4 - 1) for band in range(5)]
        def parse_rgb(x):
            return tuple(int(x[a:a+2],16)/255.0 for a in range(1,6,2))
        def inter(a, b, v):
            return tuple(ax * (1 - v) + bx * v for ax, bx in zip(a, b))
        # base_colors = map(parse_rgb, ["#121B2A", "#214373", "#5A9FD8",
        #                               "#77D0F0", "#CAF6F7"])
        base_colors = [inter(parse_rgb("#8ae234"), parse_rgb("#729fcf"), x/3.0)
                       for x in range(4)]
        # # Blend toward white
        # band_colors = [tuple(0.75 + x*0.25 for x in c) for c in base_colors]
        band_colors = [inter(c, (1,1,1), 0.75) for c in base_colors]
        with ctx:
            ctx.font_size = S / 1.25
            for band in range(4):
                top = band_ys[band]
                bot = band_ys[band+1]
                ctx.rect(BAND_LEFT * S, top, S * (38 - BAND_LEFT), bot - top,
                         fill=band_colors[band])
                for step in range(3):
                    ctx.text('XYZ'[step], S * (1 + BAND_LEFT), top + S*(step+1),
                             'cm', fill=(0,0,0,0.5))
            ctx.text('W', S * (1 + BAND_LEFT), band_ys[-1] + S, 'cm',
                     fill=(0,0,0,0.5))
        for band in range(5):
            ctx.path([('M', BAND_LEFT * S, band_ys[band]), ('H', S * 38)],
                     stroke=(0,0,0,0.3), stroke_width='2pt')

        path = []
        def render_edges(node, move):
            for label, child in node.children.items():
                if label:
                    if child.x < node.x:
                        ctx.text(label, S*node.x - LABEL_PAD,
                                 S*node.y + LABEL_PAD, 'tr')
                    elif child.x > node.x:
                        ctx.text(label, S*node.x + LABEL_PAD,
                                 S*node.y + LABEL_PAD, 'tl')
                    else:
                        ctx.text(label, S*node.x + LABEL_PAD,
                                 S*node.y + LABEL_PAD, 'tl')

                if move:
                    path.append(('M', S*node.x, S*node.y))
                path.extend([('H', S*child.x), ('V', S*child.y)])
                move = True
                render_edges(child, False)
        # Stem to the root
        path.extend([('M', S*self.__root.x, S*(self.__root.y - 1)),
                     ('V', S*self.__root.y)])
        with ctx:
            ctx.font_size = BRANCH_LABEL_SIZE
            render_edges(self.__root, False)
        ctx.path(path, stroke=(0,0,0), stroke_width=STROKE_WIDTH)

        def render_node(node):
            if node.typ == 'result':
                assert isinstance(node.val, simsym.SymbolicApplyResult)
                if node.val.value == 'C':
                    if isinstance(ctx, context.TikZ):
                        label = '\\checkmark'
                    else:
                        label = u'\u2713'
                    fill = (0,1,0)
                elif node.val.value in ('RA', 'RB', 'S'):
                    label = node.val.value[0]
                    fill = (1,0,0)
                ctx.circle(S*node.x, S*node.y, S * 0.33, fill=fill)
                ctx.text(label, S*node.x, S*node.y, 'cm', fill=(1,1,1))
            elif node.typ == 'end':
                assert isinstance(node.val, simsym.SchedNode)
                note = node.val.val
                ctx.rect(S*node.x - S*0.33, S*node.y - S*0.33,
                         S*0.66, S*0.66, fill=(1,1,1), stroke=(0,0,0),
                         stroke_width=STROKE_WIDTH)
                ctx.text(unicode(note['result']), S*node.x, S*node.y, 'cm')
            elif node.typ == 'branch':
                assert isinstance(node.val, simsym.SchedNode)
                ctx.circle(S*node.x, S*node.y, NODE_RADIUS, fill=(0,0,0))
            else:
                raise ValueError('Unknown TreeNode type %r' % node.typ)
        with ctx:
            ctx.font_size = NODE_LABEL_SIZE
            self.__apply_rec(render_node)

# Don't turn trivial state equality tests into concrete branches,
# since this makes some of the places where we hit the state equality
# test disappear from the execution tree.
simsym.options.eq_eliminate_structural = False
tree = SchedTree()
for sar in simsym.symbolic_apply(test, Rename, Rename.rename, Rename.rename):
    tree.add_sched(sar._SymbolicApplyResult__schedule, sar)
    if sar.value == 'C':
        print >>sys.stderr, simsym.simplify(sar.path_condition)
        print >>sys.stderr

# ctx = context.SVG(**{'font-family': 'Open Sans',
# #                     'font-weight': '300'
#                  })
# tree.to_ctx(ctx, S=30)

ctx = context.TikZ()
tree.to_ctx(ctx, S=13)

ctx.write_to(sys.stdout)
