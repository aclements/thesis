What fundamental opportunities for multicore scalability are latent in
software interfaces, such as system call APIs?  Can scalability
opportunities be identified even before any implementation exists,
simply by considering interface specifications?  To answer these
questions this dissertation introduces the scalable commutativity
rule:

  Whenever interface operations commute, they can be implemented in a
  way that scales.

This rule aids developers in building scalable multicore software
starting with interface design and carrying on through implementation,
testing, and evaluation.

This dissertation formalizes the scalable commutativity rule and
defines a novel form of commutativity named SIM commutativity that
makes it possible to fruitfully apply the rule to complex and highly
stateful software interfaces.

To help developers apply the rule, this dissertation introduces an
automated method embodied in a new tool named Commuter, which accepts
high-level interface models, generates tests of operations that
commute and hence could scale, and uses these tests to systematically
evaluate the scalability of implementations.  We apply Commuter to a
model of 18 POSIX file and virtual memory system operations.  Using
the resulting 26,238 scalability tests, Commuter systematically
pinpoints many problems in the Linux kernel that past work has
observed to limit application scalability and identifies previously
unknown bottlenecks that may be triggered by future hardware or
workloads.

Finally, this dissertation applies the scalable commutativity rule and
Commuter to the design and implementation of a new POSIX-like
operating system named sv6.  sv6's novel file and virtual memory
system designs enable it to scale for 99% of the tests generated by
Commuter.  These results translate to linear scalability on an 80-core
x86 machine for applications built on sv6's commutative operations.
