\section{Conflict-freedom in Linux}
\label{sec:topic:model}

\XXX[STATUS]{Split from ``Finding scalability opportunities'' in SOSP.
  Smoothed, but otherwise largely unchanged.}

To understand whether \tool{} is useful to kernel developers,
we modeled several POSIX file system and virtual memory calls in \tool,
then used this both to evaluate Linux's scalability and to develop a
scalable file and virtual memory system for our \sys research kernel.
%
The rest of this chapter focuses on Linux and uses this case study to
answer the following questions:

\begin{CompactItemize}

\item How many test cases does \tool{} generate, and what do they test?

\item How good are current implementations of the POSIX interface?
      Do the test cases generated by \tool{} find
      cases where current implementations don't scale?

\end{CompactItemize}

In the next chapter, we'll use this same POSIX model to guide the
implementation of a new operating system kernel, \sys.

\subsection{POSIX test cases}

To answer the first question, we developed a simplified model of the
POSIX file system and virtual memory APIs in \tool{}.  The model covers
\pyexpr{len(mscan.calls)} system
calls, and includes inodes, file
names, file descriptors and their offsets, hard links, link counts,
file lengths, file contents, file times, pipes, memory-mapped files,
anonymous memory, processes, and threads.  Our model
also supports nested
directories, but we disable them because Z3 does not currently handle
the resulting constraints.
\XXX[AC]{Do we want to say any more about nested directories?}
%
We restrict file sizes and offsets to page granularity; for pragmatic
reasons, some kernel data structures are designed to be conflict-free
for offsets on different pages, but
offsets within a page conflict.
%
\tool generates a total of \pyexpr{mscan.ntestcases} test cases
from our model.
%
Generating the test cases and running them on both Linux and \sys
takes a total of 8~minutes on the machine described in
\cref{sec:topic:ben}.

The model implementation and its model-specific test code generator
are \pyexpr{const['commuter-loc']['fsmodel']} and
\pyexpr{const['commuter-loc']['fstestgen']} lines of Python code,
respectively.
\Cref{fig:rename-spec} showed a part of our
model, and \cref{fig:testgen} gave an example test
case generated by \tool{}.  We verified that all test cases return
the expected results on both Linux and \sys.

% \begin{figure*}
% \small
% \centering
% \input{figures/testcases}
% \caption{
%   Scalability for system call pairs, showing the fraction and absolute
%   number
%   of test cases generated by \tool that are not
%   conflict-free for each system call pair.
%   One example test case was shown in \cref{fig:testgen}.
% }
% \label{fig:testcase-breakdown}
% \end{figure*}
\begin{figure*}
\small
\centering
\inputnodraft{figures/testcases-linux}
\caption[Conflict-freedom of commutative system call pairs in Linux.]{
  Conflict-freedom of commutative system call pairs in Linux, showing
  the fraction and absolute number of test cases generated by \tool
  that are \emph{not} conflict-free for each system call pair.  One
  example test case was shown in \cref{fig:testgen}.}
\label{fig:testcase-breakdown-linux}
\end{figure*}

\XXX[AC]{memwrite is weird because mscan ignores user space addresses,
so the actual write performed by memwrite isn't counted.  That's why
even the idempotent ones are ``conflict-free''.}

\subsection{Linux conflict-freedom}

To evaluate the scalability of existing file and virtual memory systems,
we used \mtrace{} to check the above test cases against
Linux kernel version 3.8.
Linux developers have invested significant effort in making the file
system scale~\cite{boyd-wickizer:scaling}, and it already scales in
many interesting cases, such as concurrent operations in different
directories or concurrent operations on different files in the same
directory that already exist~\cite{lwn:dcache}.
%
We evaluated the \code{ramfs} file system because
\code{ramfs} is effectively a user-space interface to the Linux buffer
cache.  Since exercising \code{ramfs} is equivalent to exercising the
buffer cache and the buffer cache underlies all Linux file
systems, this represents the best-case scalability for a Linux file
system.
%
Linux's virtual memory system, in contrast, involves process-wide
locks that are known to limit its
scalability and impact real
applications~\cite{boyd-wickizer:scaling,clements:bonsai,gil:c4}.

\XXX[AC]{Maybe call out pure FS calls and/or pure VM calls?}
\Cref{fig:testcase-breakdown-linux} shows the results.
Out of \pyexpr{mscan.ntestcases} test cases,
\pyexpr{mscan.linux.shared} cases, widely distributed across the
system call pairs, were not conflict-free.
This indicates that even a mature and reasonably scalable operating system
implementation misses many cases that can be made to scale according
to the commutativity rule.

A common source of access conflicts is shared reference counts.
%
For example, most file name lookup operations update the reference
count on a \code{struct dentry}; the resulting write conflicts cause
them to not scale.
%
Similarly, most operations that take a file descriptor update the
reference count on a \code{struct file}, making
commutative operations such as two \code{fstat} calls on the
same file descriptor not scale.
Coarse-grained locks are another source of access conflicts.  For
instance, Linux locks the parent directory for any operation that
creates file names, even though operations that create distinct names
generally commute.
%
%Many of these problems affect application
%scalability~\cite{boyd-wickizer:scaling}.
%
Similarly, we see that coarse-grained locking in the virtual memory
system severely limits the conflict-freedom of address space manipulation
operations. This agrees with previous
findings~\cite{boyd-wickizer:scaling,clements:radixvm,clements:bonsai},
which demonstrated these problems in the context of several applications.

% Another source of non-scalability is
% needless lock acquisition: for instance, Linux locks an inode when
% truncating the file in \code{open(O_TRUNC)} even if the file is
% already empty, making concurrent \code{open(O_TRUNC)} calls on an existing
% empty file non-scalable.  A final example is needless updates: if two file
% names \code{a} and \code{b} point to the same inode, \code{rename(a, b)}
% need not modify the \code{dentry} for \code{b}, but Linux does so anyway.
% \XXX[nz]{Weak examples; we should at least finish with an
% interesting/important case.}

\XXX[AC]{We carefully never analyze Linux performance, which means we
  don't show that these conflicts are really a problem.  We should
  either strengthen the above statements about previous work showing
  these to be real scalability problems, or add some Linux performance
  evaluation (\emph{not} comparing it directly against \sys, since
  that's not fair).  Then we could close with: As we'll see in
  \cref{sec:eval}, these conflicts translate directly into poor
  measured scalability for many benchmarks.}
